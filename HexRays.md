# "Закидоны" Hex-Rays

1. `*(_DWORD *)(&v17 + 56)` или `*(_DWORD *)(4 * i + v8)`

   > Не распознан массив. Должно быть: `v17[56]` или `v8[i]`.
   >
   > Нужно **прописать типы** - объявить переменную как указатель (или задать массив).
   > Например как `_DWORD *v8;` вместо `int v8;`.
   >
   > *Примечание:* может появиться запись типа `*a2 = 2 * v5 `, это то же самое, что и `a2[0] = 2 * v5`.

   `*(_DWORD *)(4LL * *(_DWORD *)(4LL * (signed int)i + a2) + a1)`

   > Не распознан массив и индекс в виде значения другого массива. Должно быть: `a1[a2[i]]`.
   >
   > **Аналогично**, нужно обявить переменные как указатели.
   > Например `_DWORD *a1, *a2`.

   ​

2. ```c
   char s;    // [sp+Dh]
   char v5;   // [sp+Eh]
   char v6;   // [sp+Fh]
   char v7;   // [sp+10h]
   size_t v8; // [sp+10Ch]
   // ...
   scanf("%s", &s);
   if (v8 != 6 || s != 113 || v5 != 119 || v6 != 101 || v7 != 114) {
      // ...
   ```

   > Распад переменных в стеке. Должно быть:
   >
   > ```c
   > char s[255]; // [sp+Dh]
   > size_t v8;   // [sp+10Ch]
   > // ...
   > scanf("%s", s);
   > if (v8 != 6 || s[0] != 113 || s[1] != 119 || s[2] != 101 || s[3] != 114) {
   >     // ...
   > ```
   >
   > Нужно **обяъвить первую переменную как массив**.
   > Например, `char s` обявить как `char s[255]`.

   ```c
   if (strlen(&Buf) > 5)
       result = byte_804A04B == 97 && byte_804A049 == 49 && byte_804A04D == 66 && Buf == 99 && byte_804A04A == 52 && byte_804A04C == 101;
   ```

   > Распад глобальных переменных. Должно быть:
   >
   > ```c
   > if (strlen(Buf) > 5)
   >     result = Buf[3] == 97 && Buf[1] == 49 && Buf[5] == 66 && Buf[0] == 99 && Buf[2] == 52 && Buf[4] == 101;
   > ```
   >
   > **Аналогично**.
   > Например, объявить переменную `Buf` как массив.

   ​

3. ```c
   __int64 v4; // [sp+0h]
   __int64 v5; // [sp+8h]
   __int64 v6; // [sp+10h]
   __int64 v7; // [sp+18h]
   __int64 v8; // [sp+20h]

   v4 = 8022916924116329800LL;
   v5 = 8243109180364582002LL;
   v6 = 8749685271133495397LL;
   v7 = 8318822935124340256LL;
   v8 = 58;
   ```

   > Строка распознана как числа. Должно быть:
   >
   > ```c
   > char v4[] = "Hello World, here are my numbers:";
   > ```
   >
   > Нужно поменять тип первой переменной с числа на символ (байт) и **создать массив**, покрывающий остальные числа. Например с `__int64 v4` на `char v4[40]`.

   ​

4. `*(_BYTE *)(i + 134520876) != *(&Buf + i - 1) + i `

   > Адрес переменной не распознан и представлен в виде числа. Должно быть: `*(&Buf + i) != *(&Buf + i - 1) + i`.
   >
   > Нужно переключиться на ассемблерный код, **обозначить число как смещение** (адрес переменной) и обновить псевдокод.

   ​

5. ```c
   v3 = &s;
   do 
   {
       v4 = *(_DWORD *)v3;
       v3 = (__int64 *)((char *)v3 + 4);
       v5 = ~v4 & (v4 - 0x1010101) & 0x80808080;
   } 
   while (!v5);
   v6 = (unsigned __int16)(v5 & 0x8080) == 0;
   if ( !(v5 && 0x8080) )
       v5 >>= 16;
   if ( v6 )
       v3 = (__int64 *)((char *)v3 + 2);
   if ( (char *)v3 + -__CFADD__((_BYTE)v5, (_BYTE)v5) - 3 - (char *)&s == 37 )
   ```

   > Компилятор оптимизировал программу, вставив код вызываемой функции в место её вызова. Должно быть:
   >
   > ```c
   > if (strlen(&s) == 37)
   > ```
   >
   > Нужно ~~плакать~~ запоминать примерный код библиотечных функций и распознавать его глазами.

   Другой пример:

   `if (strcmp(&v8, "test_test_123"))` разворачивается как:

   ```c
   v4 = "test_test_123";
   v5 = 14LL;
   v6 = &v8;
   do
   {
       if ( !v5 )
           break;
       v3 = *(_BYTE *)v6 == *v4;
       v6 = (__int64 *)((char *)v6 + 1);
       ++v4;
       --v5;
   }
   while ( v3 );
   if (v3)
   ```

   ​

6. ```c
   v8 = (unsigned __int8)(((unsigned __int64)(signed int)v8 >> 56) + v8) - ((unsigned int)((unsigned __int64)(signed int)v8 >> 32) >> 24);
   ```

   > Не распознана операция взятия остатка от деления (взятия числа по модулю). Должно быть: `v8 = v8 % 256;`.
   >
   > Опять же, нужно ~~плакать~~ смириться и распознавать такой код глазами, или пытаться загуглить константы, или **юзать [Hacker's Delight](http://www.hackersdelight.org/magic.htm)**.

   Другие примеры:

   `v3 % 13` может быть представлен как:

   ```c
   v3 - 13 * ((unsigned int)((unsigned __int64)(1321528399LL * v3) >> 32) >> 2)
   ```

   `v5 % 64` может быть представлен как: `(_BYTE)v5 & 0x3F`



