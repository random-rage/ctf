# Атаки на бинари (x86-64)

## Контроль RIP (control flow hijack)

Позволяет "прыгнуть" в любое доступное место в памяти (на любую функцию, инструкцию или в архитектурах Intel даже на "середину" инструкции).

### Способы контроля RIP

#### Перетирание хранящихся в стеке значений переменных, влияющих на ход выполнения

```c
char buf[8];
char *string_pointer = "NO WIN";

read(0, buf, 32);	// Записываем "WIN" поверх "NO WIN"

if (!strcmp(string_pointer, "WIN")) {
    system("cat flag");	// Условие выполнится
}
```



#### Перетирание хранящихся в стеке указателей на функции

```c
void win() { system("cat flag"); }
void no_win() {}

char buf[8];
void (*function_pointer)() = no_win;

read(0, buf, 32);	// Записываем указатель на win() поверх указателя на no_win()
function_pointer();	// Произойдёт вызов win()
```



#### Перетирание адреса возврата

```c
void win() { system("cat flag"); }

void play() {
    char buf[8];
    read(0, buf, 32);	// Записываем указатель на win() поверх адреса возврата из play()
}	// После выполнения функции произойдёт вызов win()
```

##### Защита от атаки на перетирание адреса возврата - канарейка (Stack canary)

1. При запуске программы генерируется случайное значение **canary** (или **__security_cookie**) размером в регистр, всегда оканчивающееся `null`-байтом, и сохраняется в специальную память, например в сегментный регистр `FS` или `GS`.

2. Данное значение кладётся на стек после вызова каждой функции:

   ```assembly
   mov	rax, fs:28h
   mov	[rbp+canary], rax
   ```

   или дополнительно `XOR`ится (Microsoft) с адресом, лежащим в RBP:

   ```assembly
   sub rsp, 8h
   mov	rax, qword ptr [__security_cookie] 
   xor	rax, rbp 
   mov	qword ptr [rbp], rax
   ```

3. Перед возвратом из функции положенное на стек значение сверяется с хранимым:

   ```assembly
   mov		rax, [rbp+canary]
   sub		rax, fs:28h
   jz		short locret_401197
   call	__stack_chk_fail # Выводит *** stack smashing detected *** и завершает программу
   locret_401197:
   leave
   retn
   ```

   или дополнительно `XOR`ится (Microsoft) с адресом, лежащим в RBP:

   ```assembly
   mov		rcx, qword ptr [rbp]
   xor		rcx, rbp 
   call	__security_check_cookie
   add		esp, 8h
   ```

4. Если значения не равны, программа немендленно завершается с ошибкой.

##### Обход защиты Stack canary

1. Не перетирать канарейку, если есть возможность - например, если можно устанавливать значения в массиве по индексу.

2. Узнать секретное значение:

   1. Прочитать по индексу массива/указателю, например - с помощью форматной строки:

      ```c
      char buf[64];
      
      read(0, buf, 64);
      
      printf(buf);	// "Hello %3$d!" - прочитать 3-й указатель
      // или
      printf(buf);	// "%p %p %p %p... %15$p %16$p..." - читать регистры и стек
      ```

   2. Подобрать побайтовым перебором (перетитрать значение **canary** по 1 байту). Такое возможно, когда процесс был создан с помощью функции `fork()` - значение **canary** оригинального процесса передаётся дочернему. Полагая, что последний байт всегда равен нулю, можно перебирать байты по порядку по одному до тех пор, пока программа не перестанет падать.

   3. Перетереть `null`-терминатор значения **canary** каким-либо другим байтом и вывести это значение как строку.

